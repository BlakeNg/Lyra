= Lyra

A simple to use, composing, command line parser for C++ 11 and beyond.

image:https://travis-ci.com/bfgroup/Lyra.svg?branch=master["Travis", link="https://travis-ci.com/bfgroup/Lyra"]
image:https://ci.appveyor.com/api/projects/status/y45imn392t6u75r4/branch/master?svg=true["Appveyor", link="https://ci.appveyor.com/project/grafikrobot/lyra/branch/master"]
image:https://img.shields.io/badge/license-BSL%201.0-blue.svg["Boost Software License 1.0", link="LICENSE.txt"]
image:https://img.shields.io/badge/standard-PFLR1-orange.svg["Pitchfork Layout R1", link="https://github.com/vector-of-bool/pitchfork"]
image:https://img.shields.io/badge/standard-C%2B%2B%2011-blue.svg?logo=C%2B%2B["C\+\+ 11", link="https://isocpp.org/"]
image:https://img.shields.io/badge/standard-C%2B%2B%2014-blue.svg?logo=C%2B%2B["C\+\+ 14", link="https://isocpp.org/"]
image:https://img.shields.io/badge/standard-C%2B%2B%2017-blue.svg?logo=C%2B%2B["C\+\+ 17", link="https://isocpp.org/"]
image:https://img.shields.io/badge/standard-C%2B%2B%202a-blue.svg?logo=C%2B%2B["C\+\+ 2a", link="https://isocpp.org/"]

== License

Distributed under the Boost Software License, Version 1.0. (See accompanying
file LICENSE.txt or copy at http://www.boost.org/LICENSE_1_0.txt)

== Features

* Header only with no external dependencies (except the std library).
* Define your interface once to get parsing, type conversions and usage
  strings with no redundancy.
* Composing. Each `Opt` or `Arg` is an independent parser. Combine these to
  produce a composite parser - this can be done in stages across multiple
  function calls -- or even projects.
* Bind parsers directly to variables that will receive the results of the parse
  -- no intermediate dictionaries to worry about.
* Or can also bind parsers to lambdas for more custom handling.
* Deduces types from bound variables or lambdas and performs type conversions
  (via `ostream <<`), with error handling, behind the scenes.
* Bind parsers to vectors for args that can have multiple values.
* Uses Result types for error propagation, rather than exceptions (doesn't yet
  build with exceptions disabled, but that will be coming later)
* Models POSIX standards for short and long opt behavior.
* Customizable option syntax.
* Specify cardinality of `Arg`-s from one to many.

== Using

To use, just `#include "lyra/lyra.hpp"`

A parser for a single option can be created like this:

[source,c++]
----
int width = 0;
// ...
using namespace lyra;
auto cli
    = Opt( width, "width" )
        ["-w"]["--width"]
        ("How wide should it be?");
----

You can use this parser directly like this:

[source,c++]
----
auto result = cli.parse( Args( argc, argv ) );
if( !result ) {
    std::cerr << "Error in command line: " << result.errorMessage() << std::endl;
    exit(1);
}

// Everything was ok, width will have a value if supplied on command line
----

Note that exceptions are not used for error handling.

You can combine parsers by composing with `|`, like this:

[source,c++]
----
int width = 0;
std::string name;
bool doIt = false;
std::string command;
auto cli
    = Opt( width, "width" )
        ["-w"]["--width"]
        ("How wide should it be?")
    | Opt( name, "name" )
        ["-n"]["--name"]
        ("By what name should I be known")
    | Opt( doIt )
        ["-d"]["--doit"]
        ("Do the thing" )
    | Arg( command, "command" )
        ("which command to run");
----

`Opt` specifies options that start with a short dash (`-`) or long dash (`--`).
On Windows forward slashes are also accepted (and automatically interpreted as
a short dash). Options can be argument taking (such as `-w 42`), in which case
the `Opt` takes a second argument -- a hint, or they are pure flags (such as
`-d`), in which case the `Opt` has only one argument -- which must be a boolean.
The option names are provided in one or more sets of square brackets, and a
description string can be provided in parentheses. The first argument to an
`Opt` is any variable, local, global member, of any type that can be converted
from a string using `std::ostream`.

`Arg` specifies arguments that are not tied to options, and so have no square
bracket names. They otherwise work just like `Opt`.

A, console optimized, usage string can be obtained by inserting the parser into
a stream. The usage string is built from the information supplied and is
formatted for the console width.

As a convenience, the standard help options (`-h`, `--help` and `-?`) can be
specified using the `Help` parser, which just takes a boolean to bind to.

== Origins

This is a fork of the dormant Clara project.